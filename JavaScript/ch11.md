# （八）数组

## 1.简介
```js
            /* 
                数组（Array）
                    - 数组也是一种复合数据类型，在数组可以存储多个不同类型的数据
                    - 数组中存储的是有序的数据，数组中的每个数据都有一个唯一的索引
                        可以通过索引来操作获取数据
                    - 数组中存储的数据叫做元素
                    - 索引（index）是一组大于0的整数
                    - 创建数组
                        通过Array()来创建数组，也可以通过[]来创建数组

                    - 向数组中添加元素
                        语法：
                            数组[索引] = 元素

                    - 读取数组中的元素
                        语法：
                            数组[索引]
                            - 如果读取了一个不存在的元素，不好报错而是返回undefined

                    - length
                        - 获取数组的长度
                        - 获取的实际值就是数组的最大索引 + 1
                        - 向数组最后添加元素：
                            数组[数组.length] = 元素
                        - length是可以修改的
            */

            const obj = { name: "孙悟空", age: 18 }

            const arr = new Array()
            const arr2 = [1, 2, 3, 4, 5] // 数组字面量

            arr[0] = 10
            arr[1] = 22
            arr[2] = 44
            arr[3] = 88
            arr[4] = 99

            // 使用数组时，应该避免非连续数组，因为它性能不好
            // arr[100] = 99

            // console.log(arr[1])

            // console.log(typeof arr) // object

            // console.log(arr.length)

            arr[arr.length] = 33
            arr[arr.length] = 55

            arr.length = 5

            console.log(arr)
```


## 遍历数组
```js
            // 任何类型的值都可以成为数组中的元素
            let arr = [1, "hello", true, null, { name: "孙悟空" }, () => {}]

            // 创建数组时尽量要确保数组中存储的数据的类型是相同
            arr = ["孙悟空", "猪八戒", "沙和尚"]

            // console.log(arr)

            /* 
                遍历数组
                    - 遍历数组简单理解，就是获取到数组中的每一个元素
            */

            // console.log(arr[0])
            // console.log(arr[1])
            // console.log(arr[2])

            arr = ["孙悟空", "猪八戒", "沙和尚", "唐僧", "白骨精"]

            // for(let i=0; i<arr.length; i++){
            //     console.log(arr[i])
            // }

            // for (let i = arr.length - 1; i >= 0; i--) {
            //     console.log(arr[i])
            // }

            /* 
                定义一个Person类，类中有两个属性name和age
                    然后创建几个Person对象，将其添加到一个数组中

                遍历数组，并打印未成年人的信息
            
            */
            class Person {
                constructor(name, age) {
                    this.name = name
                    this.age = age
                }
            }

            const personArr = [
                new Person("孙悟空", 18),
                new Person("沙和尚", 38),
                new Person("红孩儿", 8),
            ]

            for(let i=0; i<personArr.length; i++){
                if(personArr[i].age < 18){
                    console.log(personArr[i])
                }
            }
```

## for-of
```js
            /* 
                for-of语句可以用来遍历可迭代对象

                语法：
                    for(变量 of 可迭代的对象){
                        语句...
                    }

                执行流程：
                    for-of的循环体会执行多次，数组中有几个元素就会执行几次，
                        每次执行时都会将一个元素赋值给变量
            */
                    
            const arr = ["孙悟空", "猪八戒", "沙和尚", "唐僧"]

            for(let value of arr){
                console.log(value)
            }


            // for(let value of "hello"){
            //     console.log(value)
            // }

```


## 数组方法
```js
            /* 
                https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array

                Array.isArray()
                    - 用来检查一个对象是否是数组    

                at()
                    - 可以根据索引获取数组中的指定元素
                    - at可以接收负索引作为参数
                concat()
                    - 用来连接两个或多个数组
                    - 非破坏性方法，不会影响原数组，而是返回一个新的数组
            
            */

            // console.log(Array.isArray({ name: "孙悟空" })) // false
            // console.log(Array.isArray([1, 2, 3])) // true

            const arr = ["孙悟空", "猪八戒", "沙和尚", "唐僧"]

            // console.log(arr.at(-2))
            // console.log(arr[arr.length - 2])

            const arr2 = ["白骨精", "蜘蛛精", "玉兔精"]

            let result = arr.concat(arr2, ["牛魔王","铁扇公主"])

            console.log(result)






            let arr = ["孙悟空", "猪八戒", "沙和尚", "唐僧", "沙和尚"]

            /* 
                indexOf()
                    - 获取元素在数组中第一次出现的索引
                    - 参数：
                        1. 要查询的元素
                        2. 查询的其实位置
                lastIndexOf()
                    - 获取元素在数组中最后一次出现的位置

                    - 返回值：
                        找到了则返回元素的索引，
                        没有找到返回-1

                join()
                    - 将一个数组中的元素连接为一个字符串
                    - ["孙悟空", "猪八戒", "沙和尚", "唐僧", "沙和尚"] -> "孙悟空,猪八戒,沙和尚,唐僧,沙和尚"
                    - 参数：
                        指定一个字符串作为连接符

                slice()
                    - 用来截取数组（非破坏性方法）     
                    - 参数：
                        1. 截取的起始位置（包括该位置）
                        2. 截取的结束位置（不包括该位置）   
                            - 第二个参数可以省略不写，如果省略则会一直截取到最后
                            - 索引可以是负值

                        如果将两个参数全都省略，则可以对数组进行浅拷贝（浅复制）
            
            */

            let result = arr.indexOf("沙和尚", 3)
            result = arr.lastIndexOf("沙和尚", 3)
            result = arr.indexOf("白骨精")

            result = arr.join()
            result = arr.join("@-@")
            result = arr.join("")

            arr = ["孙悟空", "猪八戒", "沙和尚", "唐僧"]
            result = arr.slice(0, 2)
            result = arr.slice(1, 3)
            result = arr.slice(1, -1)

            result = arr.slice()

            console.log(result)





        /* 
            push()
                - 向数组的末尾添加一个或多个元素，并返回新的长度
            pop()
                - 删除并返回数组的最后一个元素
            unshift()
                - 向数组的开头添加一个或多个元素，并返回新的长度
            shift()
                - 删除并返回数组的第一个元素
            splice()
                - 可以删除、插入、替换数组中的元素
                - 参数：
                    1. 删除的起始位置
                    2. 删除的数量
                    3. 要插入的元素

                - 返回值：
                    - 返回被删除的元素
            reverse()
                - 反转数组
        
        */

            let result = arr.push("唐僧", "白骨精")

            // console.log(arr)

            result = arr.pop()
            arr.unshift("牛魔王")
            arr.shift()

            // console.log(arr)

            arr = ["孙悟空", "猪八戒", "沙和尚", "唐僧"]
            // result = arr.splice(1, 3)
            // result = arr.splice(1, 1, "牛魔王", "铁扇公主", "红孩儿")
            result = arr.splice(1, 0, "牛魔王", "铁扇公主", "红孩儿")

            // console.log(result)
            // console.log(arr)

            arr = ["a", "b", "c", "d"]
            arr.reverse()

            // console.log(arr)


            /* 
                有如下一个数组
                    arr = [1,2,1,3,2,4,5,5,6,7]

                编写代码，去除数组中重复的元素 --> [1,2,3,4,5,6,7]
            
            */


            const arr = [1, 2, 1, 3, 2, 2, 4, 5, 5, 6, 7]

            // 编写代码去除数组中重复的元素

            // 分别获取数组中的元素
            for (let i = 0; i < arr.length; i++) {
                // 获取当前值后边的所有值
                for (let j = i + 1; j < arr.length; j++) {
                    // 判断两个数是否相等
                    if (arr[i] === arr[j]) {
                        // 出现了重复元素，删除后边的元素
                        arr.splice(j, 1)

                        /* 
                            当arr[i] 和 arr[j]相同时，它会自动的删除j位置的元素，然后j+1位置的元素，会变成j位置的元素
                            而j位置已经比较过了，不会重复比较，所以会出现漏比较的情况

                            解决办法，当删除一个元素后，需要将该位置的元素在比较一遍
                        */
                        j--
                    }
                }
            }

            console.log(arr)



         const arr = [1, 2, 1, 3, 2, 2, 4, 5, 5, 6, 7]

        // 获取数组中的元素
        // for(let i=0; i<arr.length; i++){
        //     const index = arr.indexOf(arr[i], i+1)
        //     if(index !== -1){
        //         // 出现重复内容
        //         arr.splice(index, 1)
        //         i--
        //     }
        // }
        // console.log(arr)

        const newArr = []

        for(let ele of arr){
            if(newArr.indexOf(ele) === -1){
                newArr.push(ele)
            }
        }

        console.log(newArr)

        /* 
            有一个数组：
                [9,1,3,2,8,0,5,7,6,4]

            编写代码对数组进行排序 --> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
        */



                   /* 
                 [9,1,3,2,8,0,5,7,6,4]

                 思路一：
                    9, 1, 3, 2, 8, 0, 5, 7, 6, 4
                    - 比较相邻的两个元素，然后根据大小来决定是否交换它们的位置
                    - 例子：
                        第一次排序：1, 3, 2, 8, 0, 5, 7, 6, 4, 9
                        第二次排序：1, 2, 3, 0, 5, 7, 6, 4, 8, 9
                        第三次排序：1, 2, 0, 3, 5, 6, 4, 7, 8, 9
                        ...
                        倒数第二次 0, 1, 2, 3, 4, 5, 6, 7, 8, 9

                    - 这种排序方式，被称为冒泡排序，冒泡排序是最慢的排序方式，
                        数字少还可以凑合用，不适用于数据量较大的排序

                思路2：
                    9, 1, 3, 2, 8, 0, 5, 7, 6, 4
                    - 取出一个元素，然后将其他元素和该元素进行比较，如果其他元素比该元素小则交换两个元素的位置
                    - 例子：
                        0, 9, 3, 2, 8, 1, 5, 7, 6, 4
                        0, 1, 9, 3, 8, 2, 5, 7, 6, 4
                        0, 1, 2, 9, 8, 3, 5, 7, 6, 4
                        ...

                    - 选择排序

            */

            const arr = [9, 1, 3, 2, 8, 0, 5, 7, 6, 4]
            for (let j = 0; j < arr.length - 1; j++) {
                for (let i = 0; i < arr.length - 1; i++) {
                    // arr[i] 前边的元素 arr[i+1] 后边元素
                    if (arr[i] < arr[i + 1]) {
                        // 大数在前，小数在后，需要交换两个元素的位置
                        let temp = arr[i] // 临时变量用来存储arr[i]的值
                        arr[i] = arr[i + 1] // 将arr[i+1]的值赋给arr[i]
                        arr[i + 1] = temp // 修改arr[i+1]的值
                    }
                }
            }

            console.log(arr)




            /* 
                1, 3, 2, 8, 0, 5, 7, 6, 4, 9
                1, 2, 3, 0, 5, 7, 6, 4, 8, 9
                1, 2, 0, 3, 5, 6, 4, 7, 8, 9
                1, 0, 2, 3, 5, 4, 6, 7, 8, 9
            */

            const arr = [9, 1, 3, 2, 8, 0, 5, 7, 6, 4]
            // for (let j = 0; j < arr.length - 1; j++) {
            //     for (let i = 0; i < arr.length - 1 - j; i++) {
            //         if (arr[i] > arr[i + 1]) {
            //             let temp = arr[i] 
            //             arr[i] = arr[i + 1]
            //             arr[i + 1] = temp
            //         }
            //     }

            //     console.log(arr)

            // }

            // console.log(arr)

            /* 
                选择排序
                    - 取出一个元素，然后将其他元素和该元素进行比较，如果其他元素比该元素小则交换两个元素的位置
            */

            console.log(arr)

            for(let i=0; i<arr.length; i++){
                for(let j=i+1; j<arr.length; j++){
                    if(arr[i] > arr[j]){
                        // 交换两个元素的位置
                        let temp = arr[i]
                        arr[i] = arr[j]
                        arr[j] = temp
                    }
                }

            }

            console.log(arr)
```


## 复制对象
```js
        const arr = ["孙悟空", "猪八戒", "沙和尚"]

        // const arr2 = arr  // 不是复制
        // arr2[0] = "唐僧"

        // 如何去复制一个对象 复制必须要产生新的对象
        // 当调用slice时，会产生一个新的数组对象，从而完成对数组的复制
        const arr3 = arr.slice()


        // console.log(arr === arr2)
        // console.log(arr2)

        arr3[0] = "唐僧"

        console.log(arr)
        console.log(arr3)
        
```

## 浅拷贝深拷贝
```js
        /* 
            浅拷贝（shallow copy）
                - 通常对对象的拷贝都是浅拷贝
                - 浅拷贝顾名思义，只对对象的浅层进行复制（只复制一层）
                - 如果对象中存储的数据是原始值，那么拷贝的深浅是不重要
                - 浅拷贝只会对对象本身进行复制，不会复制对象中的属性（或元素）

            深拷贝（deep copy）
                - 深拷贝指不仅复制对象本身，还复制对象中的属性和元素
                - 因为性能问题，通常情况不太使用深拷贝
        */

        // 创建一个数组
        const arr = [{name:"孙悟空"}, {name:"猪八戒"}]
        const arr2 = arr.slice() // 浅拷贝

        const arr3 = structuredClone(arr) // 专门用来深拷贝的方法

        console.log(arr)
        console.log(arr3)
```


## 复制对象2
```js
            const arr = ["孙悟空", "猪八戒", "沙和尚"]

            const arr2 = arr.slice()

            // console.log(arr === arr2)
            /* 
                ... (展开运算符)
                    - 可以将一个数组中的元素展开到另一个数组中或者作为函数的参数传递
                    - 通过它也可以对数组进行浅复制
            */

            // const arr3 = [arr[0], arr[1], arr[2]]
            const arr3 = [...arr]
            // const arr3 = ["唐僧", ...arr, "白骨精"]

            // console.log(arr)
            // console.log(arr3)

            function sum(a, b, c) {
                return a + b + c
            }

            const arr4 = [10, 20, 30]

            let result = sum(arr4[0], arr4[1], arr4[2])
            result = sum(...arr4)

            // console.log(result)

            /* 
                对象的复制
                    - Object.assign(目标对象, 被复制的对象)
                    - 将被复制对象中的属性复制到目标对象里，并将目标对象返回

                - 也可以使用展开运算符对对象进行复制



            */

            const obj = { name: "孙悟空", age: 18 }

            // const obj2 = Object.assign({}, obj)
            const obj2 = { address: "花果山", age: 28 }

            Object.assign(obj2, obj)
            // console.log(obj2)

            const obj3 = { address: "高老庄", ...obj, age: 48 } // 将obj中的属性在新对象中展开
```

## 函数
```js
            const arr = [9, 1, 3, 2, 8, 0, 5, 7, 6, 4]
            const arr2 = [9, 8, 7, 6, 5, 4, 3, 2, 1]

            function sort(array) {
                const arr = [...array]
                for (let i = 0; i < arr.length; i++) {
                    for (let j = i + 1; j < arr.length; j++) {
                        if (arr[i] > arr[j]) {
                            // 交换两个元素的位置
                            let temp = arr[i]
                            arr[i] = arr[j]
                            arr[j] = temp
                        }
                    }
                }
                return arr
            }

            let result = sort(arr2)

            // console.log(arr2)
            // console.log(result)

            class Person {
                constructor(name, age) {
                    this.name = name
                    this.age = age
                }
            }

            const personArr = [
                new Person("孙悟空", 18),
                new Person("沙和尚", 38),
                new Person("红孩儿", 8),
                new Person("白骨精", 16),
            ]


            // filter()函数用来对数组进行过滤
            function filter(arr) {

                const newArr = []

                for (let i = 0; i < arr.length; i++) {
                    if (arr[i].age < 18) {
                        newArr.push(arr[i])
                    }
                }

                return newArr
            }

            result = filter(personArr)
            console.log(result)





            问题



            class Person {
                constructor(name, age) {
                    this.name = name
                    this.age = age
                }
            }

            const personArr = [
                new Person("孙悟空", 18),
                new Person("沙和尚", 38),
                new Person("红孩儿", 8),
                new Person("白骨精", 16),
            ]

            // filter()函数用来对数组进行过滤
            /* 
                目前我们的函数只能过滤出数组中age属性小于18的对象，
                    我们希望过滤更加灵活：
                        比如：过滤数组中age大于18的对象
                                     age大于60的对象
                                     age大于n的对象
                             过滤数组中name为xxx的对象
                             过滤数组中的偶数
                             ...


                一个函数的参数也可以是函数，
                    如果将函数作为参数传递，那么我们就称这个函数为回调函数（callback）
            
            */
            function filter(arr, cb) {
                const newArr = []

                // console.log("-->", cb)
                // cb()

                for (let i = 0; i < arr.length; i++) {
                    // arr[i].age >= 18
                    // arr[i].age > 60
                    // arr[i].age > n
                    // arr[i].name === "xxx"
                    // arr[i] % 2 === 0
                    if (cb(arr[i])) {
                        newArr.push(arr[i])
                    }
                }

                return newArr
            }

            function fn(a){
                return a.name === "孙悟空"
            }

            result = filter(personArr, fn)
            console.log(result)
```


## 高阶函数
```js

            /* 
                高阶函数
                    - 如果一个函数的参数或返回值是函数，则这个函数就称为高阶函数
                    - 为什么要将函数作为参数传递？（回调函数有什么作用？）
                        - 将函数作为参数，意味着可以对另一个函数动态的传递代码
            
            */
            class Person {
                constructor(name, age) {
                    this.name = name
                    this.age = age
                }
            }

            const personArr = [
                new Person("孙悟空", 18),
                new Person("沙和尚", 38),
                new Person("红孩儿", 8),
                new Person("白骨精", 16),
            ]

            function filter(arr, cb) {
                const newArr = []

                for (let i = 0; i < arr.length; i++) {
                    if (cb(arr[i])) {
                        newArr.push(arr[i])
                    }
                }

                return newArr
            }

            // 我们这种定义回调函数的形式比较少见，通常回调函数都是匿名函数

            // function fn(a) {
            //     return a.name === "孙悟空"
            // }

            result = filter(personArr, a => a.name === "孙悟空")
            result = filter(personArr, a => a.age >= 18)

            const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
            result = filter(arr, a => a % 2 === 0)

            console.log(result)





            /*
                希望在someFn()函数执行时，可以记录一条日志

                在不修改原函数的基础上，为其增加记录日志的功能

                可以通过高阶函数，来动态的生成一个新函数
            */

            function someFn() {
                return "hello"
            }

            function outer(cb){
                return () => {
                    console.log("记录日志~~~~~")
                    const result = cb()
                    return result
                }
            }

            let result = outer(someFn)

            // console.log(result)


            function test(){
                console.log("test~~~~")
                return "test"
            }

            let newTest = outer(test)

            newTest()
```

## 闭包
```js
            /* 
                创建一个函数，第一次调用时打印1，第二次调用打印2，以此类推

                可以利用函数，来隐藏不希望被外部访问到的变量

                闭包：
                    闭包就是能访问到外部函数作用域中变量的函数
                什么时候使用：
                    当我们需要隐藏一些不希望被别人访问的内容时就可以使用闭包
                构成闭包的要件：
                    1. 函数的嵌套
                    2. 内部函数要引用外部函数中的变量
                    3. 内部函数要作为返回值返回
            */

            // let num = 0

            // function fn(){
            //     num++
            //     console.log(num)
            // }

            // fn()

            function outer(){
                let num = 0 // 位于函数作用域中

                return () => {
                    num++
                    console.log(num)
                }
            }

            const newFn = outer()

            // console.log(newFn)
            newFn()
            newFn()
            newFn()





         let a = "全局变量a"

        /* 
            函数在作用域，在函数创建时就已经确定的（词法作用域）
                和调用的位置无关

            闭包利用的就是词法作用域
        
        */
        function fn(){
            console.log(a)
        }


        function fn2(){
            let a = "fn2中的a"

            fn()
        }

        // fn2()


        function fn3(){
            let a = "fn3中的a"

            function fn4(){
                console.log(a)
            }

            return fn4
        }

        let fn4 = fn3()

        fn4()






        注意事项

            /* 
                闭包的生命周期：
                    1. 闭包在外部函数调用时产生，外部函数每次调用都会产生一个全新的闭包
                    2. 在内部函数丢失时销毁（内部函数被垃圾回收了，闭包才会消失）

                注意事项：
                    闭包主要用来隐藏一些不希望被外部访问的内容，
                        这就意味着闭包需要占用一定的内存空间

                    相较于类来说，闭包比较浪费内存空间（类可以使用原型而闭包不能），
                        需要执行次数较少时，使用闭包
                        需要大量创建实例时，使用类
            
            */

            function outer2(){
                let num = 0
                return () => {
                    num++
                    console.log(num)
                }
            }

            let fn1 = outer2() // 独立闭包
            let fn2 = outer2() // 独立闭包

            fn1()
            fn2()

            fn1 = null
            fn2 = null
```


## 数组方法补充
```js
            /* 
                sort()
                    - sort用来对数组进行排序（会对改变原数组）
                    - sort默认会将数组升序排列
                        注意：sort默认会按照Unicode编码进行排序，所以如果直接通过sort对数字进行排序
                            可能会得到一个不正确的结果
                    - 参数：
                        - 可以传递一个回调函数作为参数，通过回调函数来指定排序规则
                            (a, b) => a - b 升序排列
                            (a, b) => b - a 降序排列
                forEach()
                    - 用来遍历数组
                    - 它需要一个回调函数作为参数，这个回调函数会被调用多次
                        数组中有几个元素，回调函数就会调用几次
                        每次调用，都会将数组中的数据作为参数传递
                    - 回调函数中有三个参数：
                        element 当前的元素
                        index 当前元素的索引
                        array 被遍历的数组

                filter()
                    - 将数组中符合条件的元素保存到一个新数组中返回
                    - 需要一个回调函数作为参数，会为每一个元素去调用回调函数，并根据返回值来决定是否将元素添加到新数组中
                    - 非破坏性方法，不会影响原数组

                map()
                    - 根据当前数组生成一个新数组
                    - 需要一个回调函数作为参数，
                        回调函数的返回值会成为新数组中的元素
                    - 非破坏性方法不会影响原数组

                reduce()
                    - 可以用来将一个数组中的所有元素整合为一个值
                    - 参数：
                        1. 回调函数，通过回调函数来指定合并的规则
                        2. 可选参数，初始值

            */

            // console.log(arr)

            // arr.sort()
            arr.sort((a, b) => a - b)
            arr.sort((a, b) => b - a)

            // console.log(arr)

            arr = ["孙悟空", "猪八戒", "沙和尚", "唐僧"]

            // arr.forEach((element, index, array) => {
            //     console.log(array)
            // })

            // arr.forEach((element, index) => console.log(index, element))

            arr = [1, 2, 3, 4, 5, 6, 7, 8]

            // 获取数组中的所有偶数
            let result = arr.filter((ele) => ele > 5)

            result = arr.map((ele) => ele * 2)

            arr = ["孙悟空", "猪八戒", "沙和尚"]

            result = arr.map((ele) => "<li>" + ele + "</li>")

            arr = [1, 2, 3, 4, 5, 6, 7, 8]

            result = arr.reduce((a, b) => {
                /* 
                    1, 2
                    3, 3
                    6, 4
                    10, 5
                
                */
                // console.log(a, b)

                return a * b
            })

            // result = arr.reduce((a, b) => a + b, 10)
           

            console.log(result)
```


## 可变参数
```js
            function fn() {
                /* 
                    arguments
                        - arguments是函数中又一个隐含参数
                        - arguments是一个类数组对象（伪数组）
                            和数组相似，可以通过索引来读取元素，也可以通过for循环变量，但是它不是一个数组对象，不能调用数组的方法
                        - arguments用来存储函数的实参，
                            无论用户是否定义形参，实参都会存储到arguments对象中
                            可以通过该对象直接访问实参
                */

                // console.log(arguments[2])
                // console.log(Array.isArray(arguments))
                // for (let i = 0; i < arguments.length; i++) {
                //     console.log(arguments[i])
                // }

                // for(let v of arguments){
                //     console.log(v)
                // }

                arguments.forEach((ele) => console.log(ele))
            }

            // fn(1, 10, 33)

            // 定义一个函数，可以求任意个数值的和
            function sum() {
                // 通过arguments，可以不受参数数量的限制更加灵活的创建函数
                let result = 0

                for (let num of arguments) {
                    result += num
                }

                return result
            }

            /* 
                可变参数，在定义函数时可以将参数指定为可变参数
                    - 可变参数可以接收任意数量实参，并将他们统一存储到一个数组中返回
                    - 可变参数的作用和arguments基本是一致，但是也具有一些不同点：
                        1. 可变参数的名字可以自己指定
                        2. 可变参数就是一个数组，可以直接使用数组的方法
                        3. 可变参数可以配合其他参数一起使用
            */

            function fn2(...abc) {
                console.log(abc)
            }

            function sum2(...num) {
                return num.reduce((a, b) => a + b, 0)
            }

            // 当可变参数和普通参数一起使用时，需要将可变参数写到最后
            function fn3(a, b, ...args) {
                // for (let v of arguments) {
                //     console.log(v)
                // }

                console.log(args)
            }

            fn3(123, 456, "hello", true, "1111")
```


## 函数
```js
            /* 
                根据函数调用方式的不同，this的值也不同：
                    1. 以函数形式调用，this是window
                    2. 以方法形式调用，this是调用方法的对象
                    3. 构造函数中，this是新建的对象
                    4. 箭头函数没有自己的this，由外层作用域决定
                    5. 通过call和apply调用的函数，它们的第一个参数就是函数的this
            
            */
            function fn() {
                console.log("函数执行了~", this)
            }

            const obj = { name: "孙悟空", fn }

            /* 
                调用函数除了通过 函数() 这种形式外，还可以通过其他的方式来调用函数
                    比如，我们可以通过调用函数的call()和apply()来个方法来调用函数
                        函数.call()
                        函数.apply()
                        - call 和 apply除了可以调用函数，还可以用来指定函数中的this
                        - call和apply的第一个参数，将会成为函数的this
                        - 通过call方法调用函数，函数的实参直接在第一个参数后一个一个的列出来
                        - 通过apply方法调用函数，函数的实参需要通过一个数组传递
            */

            // fn.call(obj)
            // fn.apply(console)

            function fn2(a, b) {
                console.log("a =", a, "b =", b, this)
            }

            // fn2.call(obj, "hello", true)
            fn2.apply(obj, ["hello", true])
```


## blind
```js
            /* 
            
                根据函数调用方式的不同，this的值也不同：
                    1. 以函数形式调用，this是window
                    2. 以方法形式调用，this是调用方法的对象
                    3. 构造函数中，this是新建的对象
                    4. 箭头函数没有自己的this，由外层作用域决定
                    5. 通过call和apply调用的函数，它们的第一个参数就是函数的this
                    6. 通过bind返回的函数，this由bind第一个参数决定（无法修改）

                bind() 是函数的方法，可以用来创建一个新的函数
                    - bind可以为新函数绑定this
                    - bind可以为新函数绑定参数

                箭头函数没有自身的this，它的this由外层作用域决定，
                    也无法通过call apply 和 bind修改它的this 
                    箭头函数中没有arguments
            */

            function fn(a, b, c) {
                console.log("fn执行了~~~~", this)
                console.log(a, b, c)
            }

            const obj = {name:"孙悟空"}

            const newFn = fn.bind(obj, 10, 20, 30)

            // newFn()


            const arrowFn = () => {
                console.log(this)
            }

            // arrowFn.call(obj)

            const newArrowFn = arrowFn.bind(obj)

            // newArrowFn()

            class MyClass{
                fn = () => {
                    console.log(this)
                }
            }

            const mc = new MyClass()

            // mc.fn.call(window)
```


## 1.简介
```js
```


## 1.简介
```js
```


## 1.简介
```js
```